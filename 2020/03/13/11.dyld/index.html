<!DOCTYPE html>
<html>
<head>
    

    

    



    <meta charset="utf-8">
    
    
    
    
    <title>详解 dyld 加载过程 | Caio&#39;s Blog | Move And Go On</title>
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    
    <meta name="theme-color" content="#3F51B5">
    
    
    <meta name="keywords" content="动态链接">
    <meta name="description" content="超长预警……. 本文将会从dyld接管进程开始，超级详细的分析&#x2F;解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。  dyld 加载过程dyld的启动入口在 dyldStartup.s 文件的汇编代码中，代码入口说明了:在内核初始化完成进程，并且load 完可执行文件之后，把环境变量等">
<meta property="og:type" content="article">
<meta property="og:title" content="详解 dyld 加载过程">
<meta property="og:url" content="https://caio.ink/2020/03/13/11.dyld/index.html">
<meta property="og:site_name" content="Caio&#39;s Blog">
<meta property="og:description" content="超长预警……. 本文将会从dyld接管进程开始，超级详细的分析&#x2F;解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。  dyld 加载过程dyld的启动入口在 dyldStartup.s 文件的汇编代码中，代码入口说明了:在内核初始化完成进程，并且load 完可执行文件之后，把环境变量等">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d61a14b2aeeb66a2eea1be2d8be6b85f.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/9ac92176b89d0c92d76d1d98ecddd5f4.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/ffdc0da28d16d220f66e8d638a7d5198.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/69f3c8a3511f6c75d8798c62db21d597.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/8479e0316c7f0447ff14dd0a1b98ed69.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/6880c3f245ce10b72f214d8851b959e5.png">
<meta property="og:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d26ee1e5057ed5fc0c63d13baac4b77b.png">
<meta property="article:published_time" content="2020-03-12T16:00:00.000Z">
<meta property="article:modified_time" content="2020-05-07T09:35:32.009Z">
<meta property="article:author" content="Caio">
<meta property="article:tag" content="动态链接">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png">
    
    <link rel="shortcut icon" href="/img/favicon.png">
    <link rel="stylesheet" href="//unpkg.com/hexo-theme-material-indigo@latest/css/style.css">
    <script>window.lazyScripts=[]</script>

    <!-- custom head -->
    

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
    <div id="loading" class="active"></div>

    <aside id="menu" class="hide" >
  <div class="inner flex-row-vertical">
    <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menu-off">
        <i class="icon icon-lg icon-close"></i>
    </a>
    <div class="brand-wrap" style="background-image:url(/img/bg.png)">
      <div class="brand">
        <a href="/" class="avatar waves-effect waves-circle waves-light">
          <img src="/img/avatar.jpg">
        </a>
        <hgroup class="introduce">
          <h5 class="nickname">Caio</h5>
          <a href="mailto:omblcky@gmail.com" title="omblcky@gmail.com" class="mail">omblcky@gmail.com</a>
        </hgroup>
      </div>
    </div>
    <div class="scroll-wrap flex-col">
      <ul class="nav">
        
            <li class="waves-block waves-effect">
              <a href="/"  >
                <i class="icon icon-lg icon-home"></i>
                Home
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/archives"  >
                <i class="icon icon-lg icon-archives"></i>
                Archives
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/tags"  >
                <i class="icon icon-lg icon-tags"></i>
                Tags
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="/categories"  >
                <i class="icon icon-lg icon-th-list"></i>
                Categories
              </a>
            </li>
        
            <li class="waves-block waves-effect">
              <a href="https://github.com/caio-x" target="_blank" >
                <i class="icon icon-lg icon-github"></i>
                Github
              </a>
            </li>
        
      </ul>
    </div>
  </div>
</aside>

    <main id="main">
        <header class="top-header" id="header">
    <div class="flex-row">
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light on" id="menu-toggle">
          <i class="icon icon-lg icon-navicon"></i>
        </a>
        <div class="flex-col header-title ellipsis">详解 dyld 加载过程</div>
        
        <div class="search-wrap" id="search-wrap">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="back">
                <i class="icon icon-lg icon-chevron-left"></i>
            </a>
            <input type="text" id="key" class="search-input" autocomplete="off" placeholder="输入感兴趣的关键字">
            <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="search">
                <i class="icon icon-lg icon-search"></i>
            </a>
        </div>
        
        
        <a href="javascript:;" class="header-icon waves-effect waves-circle waves-light" id="menuShare">
            <i class="icon icon-lg icon-share-alt"></i>
        </a>
        
    </div>
</header>
<header class="content-header post-header">

    <div class="container fade-scale">
        <h1 class="title">详解 dyld 加载过程</h1>
        <h5 class="subtitle">
            
                <time datetime="2020-03-12T16:00:00.000Z" itemprop="datePublished" class="page-time">
  2020-03-13
</time>


	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E5%8A%A8%E6%80%81%E5%BA%93/">动态库</a></li></ul>

            
        </h5>
    </div>

    


</header>


<div class="container body-wrap">
    
    <aside class="post-widget">
        <nav class="post-toc-wrap post-toc-shrink" id="post-toc">
            <h4>TOC</h4>
            <ol class="post-toc"><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#dyld-加载过程"><span class="post-toc-number">1.</span> <span class="post-toc-text">dyld 加载过程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#RebaseDyld"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">RebaseDyld</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#初始化Dyld的构造器函数"><span class="post-toc-number">1.2.</span> <span class="post-toc-text">初始化Dyld的构造器函数</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#dyld-main函数"><span class="post-toc-number">2.</span> <span class="post-toc-text">dyld::_main函数</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#实例化主程序"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">实例化主程序</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#加载动态库"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">加载动态库</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Link-可执行文件"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">Link 可执行文件</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#Rebase"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">Rebase</span></a></li></ol></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#initializeMainExecutable"><span class="post-toc-number">3.</span> <span class="post-toc-text">initializeMainExecutable</span></a></li><li class="post-toc-item post-toc-level-2"><a class="post-toc-link" href="#参考文献"><span class="post-toc-number">4.</span> <span class="post-toc-text">参考文献</span></a></li></ol>
        </nav>
    </aside>


<article id="post-11.dyld"
  class="post-article article-type-post fade" itemprop="blogPost">

    <div class="post-card">
        <h1 class="post-card-title">详解 dyld 加载过程</h1>
        <div class="post-meta">
            <time class="post-time" title="2020-03-13 00:00:00" datetime="2020-03-12T16:00:00.000Z"  itemprop="datePublished">2020-03-13</time>

            
	<ul class="article-category-list"><li class="article-category-list-item"><a class="article-category-list-link" href="/categories/%E5%8A%A8%E6%80%81%E5%BA%93/">动态库</a></li></ul>



            

        </div>
        <div class="post-content" id="post-content" itemprop="postContent">
            <p>超长预警…….</p>
<p>本文将会从dyld接管进程开始，超级详细的分析/解释，dyld 是如何把若干个动态库“组装”在一起，在ASLR的影响下形成一个完整的可执行进程，以及objc的runtime如何在dyld的初始化过程中进行实例化。</p>
<hr>
<h2 id="dyld-加载过程"><a href="#dyld-加载过程" class="headerlink" title="dyld 加载过程"></a>dyld 加载过程</h2><p>dyld的启动入口在 dyldStartup.s 文件的汇编代码中，代码入口说明了:在内核初始化完成进程，并且load 完可执行文件之后，把环境变量等参数压栈，并且调用dyld的入口函数<code>__dyld_start</code>，而这个函数则根据调用约定，准备完调用参数之后，就直接跳转到<code>dyld::start</code> 这个函数。</p>
<p>接下来看<code>dyld::start</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">uintptr_t</span> <span class="title">start</span><span class="params">(<span class="keyword">const</span> struct macho_header* appsMachHeader, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], </span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">intptr_t</span> slide, <span class="keyword">const</span> struct macho_header* dyldsMachHeader,</span></span></span><br><span class="line"><span class="function"><span class="params">				<span class="keyword">uintptr_t</span>* startGlue)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// if kernel had to slide dyld, we need to fix up load sensitive locations</span></span><br><span class="line">	<span class="comment">// we have to do this before using any global variables</span></span><br><span class="line">    <span class="comment">//获取内核对于dyld本身的动态偏移</span></span><br><span class="line">    slide = slideOfMainExecutable(dyldsMachHeader);</span><br><span class="line">    <span class="keyword">bool</span> shouldRebase = slide != <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ( shouldRebase ) &#123;</span><br><span class="line">        <span class="comment">//rebase Dyld</span></span><br><span class="line">        rebaseDyld(dyldsMachHeader, slide);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// allow dyld to use mach messaging</span></span><br><span class="line">    <span class="comment">//mach消息初始化。</span></span><br><span class="line">	mach_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">// kernel sets up env pointer to be just past end of agv array</span></span><br><span class="line">    <span class="comment">//环境变量</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** envp = &amp;argv[argc+<span class="number">1</span>];</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// kernel sets up apple pointer to be just past end of envp array</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>** apple = envp;</span><br><span class="line">	<span class="keyword">while</span>(*apple != <span class="literal">NULL</span>) &#123; ++apple; &#125;</span><br><span class="line">	++apple;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// set up random value for stack canary</span></span><br><span class="line">	__guard_setup(apple);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> DYLD_INITIALIZER_SUPPORT</span></span><br><span class="line">	<span class="comment">// run all C++ initializers inside dyld</span></span><br><span class="line">    <span class="comment">//初始化 在dyld中的 所有的C++构造器</span></span><br><span class="line">	runDyldInitializers(dyldsMachHeader, slide, argc, argv, envp, apple);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="comment">// now that we are done bootstrapping dyld, call dyld's main</span></span><br><span class="line">    <span class="comment">//至此bootstrap dyld已经全部完成，调用 dyld 的 main 函数</span></span><br><span class="line">	<span class="keyword">uintptr_t</span> appsSlide = slideOfMainExecutable(appsMachHeader);</span><br><span class="line">	<span class="keyword">return</span> dyld::   _main(appsMachHeader, appsSlide, argc, argv, envp, apple, startGlue);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>dyld::start</code>的函数分为以下几步骤：</p>
<ol>
<li><span id="return_rebaseDyld">rebase dyld本身</span><br><a href="#jump_rebaseDyld">rebase dyld</a></li>
<li>初始化进程间通讯 mach_msg<br> 直接调用&lt;mach/mach_init.h&gt;内的某个内核调用</li>
<li>初始化环境变量<br> 从调用参数中拿到apple指针，内核会把这个指针紧跟在envp的数组最后</li>
<li>设置栈保护<br> 从第三步拿到的apple指针中找到“stack_guard=xx”的字符串，自定义重置栈保护</li>
<li><span id="return_runDyldInitializers">初始化 dyld 中的所有构造器函数</span><br> 因为dyld本身是一个动态库，我们知道，动态库是共享的，但是共享的只是代码段(PIC 位置无关代码)。在内核给每一个进程的虚拟地址映射完dyld之后，dyld本身这个动态库的数据段是没有初始化的，需要自己做自己的初始化。<a href="#jump_runDyldInitializers">具体代码看这里</a></li>
<li>前五步已经完成 dyld 的自启动(bootstrap)，后面就是进入真正的 dyld main函数。</li>
</ol>
<p>这里可以总结一下，start的工作内容主要是一些全局环境，以及dyld自身的初始化。</p>
<p><a href="#jump__main">开始 分析 dyld 的_main函数</a></p>
<h3 id="RebaseDyld"><a href="#RebaseDyld" class="headerlink" title="RebaseDyld"></a><span id="jump_rebaseDyld">RebaseDyld</span></h3><p>因为Dyld也是一个动态库，和普通的动态库一样，会在mach_o的load_command中指定要求需要加载到某个虚拟地址下。但是内核还是会对dyld做地址随机偏移，如果是这样，dyld需要修复数据段的数据。</p>
<ol>
<li>找到Load_Commands中 <strong>LINKEDIT 和 LC_DYLD_INFO_ONLY 两段，</strong>LINKEDIT段内包含了链接信息，符号表，动态符号表等等，而LC_DYLD_INFO_ONLY内标明了：Rebase,Bind,WeakBind,LazyBind,Export 这个5类，而这5类都会存储在Dynamic Loader Info这一节中。</li>
<li>根据rebase 和 bind 的 Opcodes等，循环进行。</li>
</ol>
<p>在后文rebase/bind 可执行文件依赖的动态库时，会进行详细说明。</p>
<p><a href="#return_rebaseDyld">回去继续</a></p>
<h3 id="初始化Dyld的构造器函数"><a href="#初始化Dyld的构造器函数" class="headerlink" title="初始化Dyld的构造器函数"></a><span id="jump_runDyldInitializers">初始化Dyld的构造器函数</span></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> Initializer  inits_start  __asm(<span class="string">"section$start$__DATA$__mod_init_func"</span>);</span><br><span class="line"><span class="keyword">extern</span> <span class="keyword">const</span> Initializer  inits_end    __asm(<span class="string">"section$end$__DATA$__mod_init_func"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="comment">// For a regular executable, the crt code calls dyld to run the executables initializers.</span></span><br><span class="line"><span class="comment">// For a static executable, crt directly runs the initializers.</span></span><br><span class="line"><span class="comment">// dyld (should be static) but is a dynamic executable and needs this hack to run its own initializers.</span></span><br><span class="line"><span class="comment">// We pass argc, argv, etc in case libc.a uses those arguments</span></span><br><span class="line"><span class="comment">//</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">runDyldInitializers</span><span class="params">(<span class="keyword">const</span> struct macho_header* mh, <span class="keyword">intptr_t</span> slide, <span class="keyword">int</span> argc, <span class="keyword">const</span> <span class="keyword">char</span>* argv[], <span class="keyword">const</span> <span class="keyword">char</span>* envp[], <span class="keyword">const</span> <span class="keyword">char</span>* apple[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">const</span> Initializer* p = &amp;inits_start; p &lt; &amp;inits_end; ++p) &#123;</span><br><span class="line">		(*p)(argc, argv, envp, apple);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在dyld的该方法的注释上，苹果写的很清楚：对于常规的可执行文件，crt代码会通过调用dyld来初始化这个可执行文件的初始化构造器。但是对于静态可执行文件，crt会自己去执行初始化。dyld可以认为是“静态”的，但是本质是一个动态库，所以需要自己来初始化自己，但是苹果称之为hack的方式。</p>
<p>实际上这是一段内联汇编，<code>__asm(&quot;section$start$__DATA$__mod_init_func&quot;)</code>意思是：获取<code>__DATA</code>段<code>__mod_init_func</code>的起始地址，当然下面那行就是获取结束地址了。</p>
<p>在Demo代码中加入两个构造器：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/81503ddc20aec519b01d09370a4d1628.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>然后再看这个mach-o 文件：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d61a14b2aeeb66a2eea1be2d8be6b85f.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>可以看到在数据段增加了一节<code>__mod_init_func</code>,编译期会把所有构造器的函数地址，都放在这节中。例如这个Section中第一个地址存储的是demo_init1的函数地址，去掉虚拟起始地址，文件内偏移地址就是0xED0：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/9ac92176b89d0c92d76d1d98ecddd5f4.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>可以直接验证确实是这个函数，<code>demo_init2</code>也是如此。</p>
<p>回过头来看，dyld的代码：这个<code>inits_start</code>中就是构造器列表中第一个构造器的函数地址了。<code>inits_end</code>就是结束地址，循环即可依次按照约定，初始化dyld自己内部的所有构造器函数了。</p>
<p>在dyld的内部还会有很多诸如此类的用法。<br>具体可以看<a href="#jump_end">参考文献</a>中 1 和 2</p>
<p><a href="#return_runDyldInitializers">回去继续</a></p>
<h2 id="dyld-main函数"><a href="#dyld-main函数" class="headerlink" title="dyld::_main函数"></a><span id="jump__main">dyld::_main函数</span></h2><p>在dyld自身的rebase和bind、mach_msg初始化、环境变量初始化、构造函数初始化全部完成之后，开始dyld的真正工作内容，<code>dyld::_main</code> 函数。</p>
<p><code>dyld::_main</code>函数最终是返回了主进程App可执行文件的main函数入口，并且由<code>dyld::start</code>函数再返回给调用它的<code>__dyld_start</code>这个汇编函数，最终由最开始的这个汇编函数，准备好调用参数之后，直接调用我们所熟悉的可执行文件的main函数。</p>
<p>这个_main函数很长，我们只看步骤。</p>
<ol>
<li>进入函数的最开始是对环境变量的初始化加载和控制，例如 crashlog，环境变量控制log，主进程可执行文件路径…</li>
<li>加载共享缓存。<code>// iOS cannot run without shared region</code>,iOS必须开启共享共享缓存。<br> 在所有libpath中搜索不到对应名字的动态库的时候，就会尝试从共享缓存中找。（当然这里为了便于理解，只是简单这样描述，实际的搜索方式远比这个要复杂）</li>
<li><span id="return_initMainExecutable">实例化可执行文件:</span><br> 实例化可执行程序，生成<code>ImageLoaderMachO</code>对象。<a href="#jump_initMainExecutable">实例化主程序</a><br> 实例化可执行文件有两种（Classic和Compressed），分别由<code>ImageLoaderMachOCompressed</code>和<code>ImageLoaderMachOClassic</code>来创建可执行文件对象，这两者均继承于<code>ImageLoaderMachO</code>。</li>
<li>加载从参数插入的动态库<code>loadInsertedDylib</code>，只做加载，不做链接。<a href="#jump_loaddylib">Load 插入的动态库</a><span id="return_loaddylib">.</span></li>
<li><span id="return_link_execution">链接可执行程序。</span><a href="#jump_link_execution">链接可执行程序</a></li>
<li>链接从参数插入的动态库。</li>
<li>从可执行文件，递归开始调用初始化。</li>
</ol>
<h3 id="实例化主程序"><a href="#实例化主程序" class="headerlink" title="实例化主程序"></a><span id="jump_initMainExecutable">实例化主程序</span></h3><p>在dyld获得控制权之前，内核已经把可执行文件映射到了某个线性地址空间了，所以dyld可以直接获取到 macho_header，dyld会为可执行文件创建一个ImageLoader实例对象，每一个MachO在dyld中都会有一个这个对象与之对应。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoaderMachO* <span class="title">instantiateFromLoadedImage</span><span class="params">(<span class="keyword">const</span> macho_header* mh, <span class="keyword">uintptr_t</span> slide, <span class="keyword">const</span> <span class="keyword">char</span>* path)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO((<span class="keyword">const</span> <span class="keyword">uint8_t</span>*)mh, path) ) &#123;</span><br><span class="line">		ImageLoader* image = ImageLoaderMachO::instantiateMainExecutable(mh, slide, path, gLinkContext);</span><br><span class="line">		addImage(image);</span><br><span class="line">		<span class="keyword">return</span> (ImageLoaderMachO*)image;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">throw</span> <span class="string">"main executable not a known format"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>instantiateMainExecutable</code>这个方法内还会根据不同的mach-o类型(compress 或者 classic)来返回ImageLoader的不同实现的子类对象。</p>
<p><code>addImage(image);</code>这个函数有两个作用：</p>
<ol>
<li>把生成的镜像实例（ImageLoader）加入到一个全局镜像容器<code>sAllImages</code>内。之后加载的所有动态库都会被加入这个容器。</li>
<li>把可执行文件的每一个段所占据的实际线性地址范围，映射到一个全局链表 <code>sMappedRangesStart</code>内，而这个全局链表的作用就是为了能够快速的通过 地址 反向获取到对应的<code>ImageLoader</code>。</li>
</ol>
<p><a href="#return_initMainExecutable">回去继续</a></p>
<h3 id="加载动态库"><a href="#加载动态库" class="headerlink" title="加载动态库"></a><span id="jump_loaddylib">加载动态库</span></h3><p>这一步循环遍历DYLD_INSERT_LIBRARIES环境变量中指定的动态库列表，并调用loadInsertedDylib()将其加载。</p>
<p>该函数调用load()完成加载工作。load()会调用loadPhase0()尝试从文件加载，loadPhase0()会向下调用下一层phase来查找动态库的路径，直到loadPhase6()，查找的顺序为DYLD_ROOT_PATH-&gt;LD_LIBRARY_PATH-&gt;DYLD_FRAMEWORK_PATH-&gt;原始路径-&gt;DYLD_FALLBACK_LIBRARY_PATH。</p>
<p>找到后调用ImageLoaderMachO::instantiateFromFile()来实例化一个 ImageLoader，之后调用 checkandAddImage() 验证映像并将其加入到全局镜像列表中。</p>
<p>如果loadPhase0()返回为空，表示在路径中没有找到动态库，就尝试从共享缓存中查找，找到就调用ImageLoaderMachO::instantiateFromCache()从缓存中加载。</p>
<p>否则就抛出没找到镜像的异常。</p>
<p>看加载动态库部分的源代码：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// map in file and instantiate an ImageLoader</span></span><br><span class="line"><span class="comment">// 映射某个动态库文件并且实例化一个ImagerLoader</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">loadPhase6</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> struct stat&amp; stat_buf, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">const</span> LoadContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("%s(%s)\n", __func__ , path);</span></span><br><span class="line">	<span class="keyword">uint64_t</span> fileOffset = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">uint64_t</span> fileLength = stat_buf.st_size;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// validate it is a file (not directory)</span></span><br><span class="line">	<span class="keyword">if</span> ( (stat_buf.st_mode &amp; S_IFMT) != S_IFREG ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"not a file"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint8_t</span> firstPages[MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE];</span><br><span class="line">	<span class="keyword">uint8_t</span> *firstPagesPtr = firstPages;</span><br><span class="line">	<span class="keyword">bool</span> shortPage = <span class="literal">false</span>;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// min mach-o file is 4K</span></span><br><span class="line">	<span class="comment">// 最小的mach-o文件就是4k（保证一个页框大小）</span></span><br><span class="line">	<span class="keyword">if</span> ( fileLength &lt; <span class="number">4096</span> ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( pread(fd, firstPages, (<span class="keyword">size_t</span>)fileLength, <span class="number">0</span>) != (<span class="keyword">ssize_t</span>)fileLength )</span><br><span class="line">			throwf(<span class="string">"pread of short file failed: %d"</span>, errno);</span><br><span class="line">		shortPage = <span class="literal">true</span>;</span><br><span class="line">	&#125; </span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">// optimistically read only first 4KB</span></span><br><span class="line">		<span class="comment">// 优先读取header文件的4kb，因为一个分页最小是4k。</span></span><br><span class="line">		<span class="keyword">if</span> ( pread(fd, firstPages, <span class="number">4096</span>, <span class="number">0</span>) != <span class="number">4096</span> )</span><br><span class="line">			throwf(<span class="string">"pread of first 4K failed: %d"</span>, errno);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// if fat wrapper, find usable sub-file</span></span><br><span class="line">	<span class="comment">// 如果这个动态库是个fat文件，就直接找到合适的“子文件”</span></span><br><span class="line">	<span class="keyword">const</span> fat_header* fileStartAsFat = (fat_header*)firstPages;</span><br><span class="line">	<span class="keyword">if</span> ( fileStartAsFat-&gt;magic == OSSwapBigToHostInt32(FAT_MAGIC) ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( OSSwapBigToHostInt32(fileStartAsFat-&gt;nfat_arch) &gt; ((<span class="number">4096</span> - <span class="keyword">sizeof</span>(fat_header)) / <span class="keyword">sizeof</span>(fat_arch)) )</span><br><span class="line">			throwf(<span class="string">"fat header too large: %u entries"</span>, OSSwapBigToHostInt32(fileStartAsFat-&gt;nfat_arch));</span><br><span class="line">		<span class="keyword">if</span> ( fatFindBest(fileStartAsFat, &amp;fileOffset, &amp;fileLength) ) &#123;</span><br><span class="line">			<span class="keyword">if</span> ( (fileOffset+fileLength) &gt; (<span class="keyword">uint64_t</span>)(stat_buf.st_size) )</span><br><span class="line">				throwf(<span class="string">"truncated fat file.  file length=%llu, but needed slice goes to %llu"</span>, stat_buf.st_size, fileOffset+fileLength);</span><br><span class="line">			<span class="keyword">if</span> (pread(fd, firstPages, <span class="number">4096</span>, fileOffset) != <span class="number">4096</span>)</span><br><span class="line">				throwf(<span class="string">"pread of fat file failed: %d"</span>, errno);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"no matching architecture in universal wrapper"</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try mach-o loader</span></span><br><span class="line">	<span class="keyword">if</span> ( shortPage ) </span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"file too short"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( isCompatibleMachO(firstPages, path) ) &#123;</span><br><span class="line"></span><br><span class="line">		<span class="comment">// only MH_BUNDLE, MH_DYLIB, and some MH_EXECUTE can be dynamically loaded</span></span><br><span class="line">		<span class="keyword">const</span> mach_header* mh = (mach_header*)firstPages;</span><br><span class="line">		<span class="keyword">switch</span> ( mh-&gt;filetype ) &#123;</span><br><span class="line">			<span class="keyword">case</span> MH_EXECUTE:</span><br><span class="line">			<span class="keyword">case</span> MH_DYLIB:</span><br><span class="line">			<span class="keyword">case</span> MH_BUNDLE:</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			<span class="keyword">default</span>:</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"mach-o, but wrong filetype"</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">uint32_t</span> headerAndLoadCommandsSize = <span class="keyword">sizeof</span>(macho_header) + mh-&gt;sizeofcmds;</span><br><span class="line">		<span class="keyword">if</span> ( headerAndLoadCommandsSize &gt; MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE )</span><br><span class="line">			throwf(<span class="string">"malformed mach-o: load commands size (%u) &gt; %u"</span>, headerAndLoadCommandsSize, MAX_MACH_O_HEADER_AND_LOAD_COMMANDS_SIZE);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( headerAndLoadCommandsSize &gt; fileLength )</span><br><span class="line">			dyld::throwf(<span class="string">"malformed mach-o: load commands size (%u) &gt; mach-o file size (%llu)"</span>, headerAndLoadCommandsSize, fileLength);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> ( headerAndLoadCommandsSize &gt; <span class="number">4096</span> ) &#123;</span><br><span class="line">			<span class="comment">// read more pages</span></span><br><span class="line">			<span class="comment">// 如果 head 和 LC_COMMANDS的大小大于已读取的4096，那么就继续把 headerAndLoadCommandsSize 读完</span></span><br><span class="line">			<span class="keyword">unsigned</span> readAmount = headerAndLoadCommandsSize - <span class="number">4096</span>;</span><br><span class="line">			<span class="keyword">if</span> ( pread(fd, &amp;firstPages[<span class="number">4096</span>], readAmount, fileOffset+<span class="number">4096</span>) != readAmount )</span><br><span class="line">				throwf(<span class="string">"pread of extra load commands past 4KB failed: %d"</span>, errno);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TARGET_IPHONE_SIMULATOR	</span></span><br><span class="line">		<span class="comment">// &lt;rdar://problem/14168872&gt; dyld_sim should restrict loading osx binaries</span></span><br><span class="line">		<span class="keyword">if</span> ( !isSimulatorBinary(firstPages, path) ) &#123;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> TARGET_OS_WATCH</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but not built for watchOS simulator"</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">elif</span> TARGET_OS_TV</span></span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but not built for tvOS simulator"</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but not built for iOS simulator"</span>;</span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __MAC_OS_X_VERSION_MIN_REQUIRED</span></span><br><span class="line">		<span class="keyword">if</span> ( gLinkContext.marzipan ) &#123;</span><br><span class="line">			<span class="keyword">const</span> dyld3::MachOFile* mf = (dyld3::MachOFile*)firstPages;</span><br><span class="line">			<span class="keyword">bool</span> isiOSMacBinary = mf-&gt;supportsPlatform(dyld3::Platform::iOSMac) || iOSMacWhiteListed(path);</span><br><span class="line">			<span class="keyword">bool</span> isProhibitedMacOSBinary = !isiOSMacBinary &amp;&amp; iOSMacBlackListed(path);</span><br><span class="line">			<span class="keyword">if</span> ( (context.enforceIOSMac &amp;&amp; !isiOSMacBinary) || isProhibitedMacOSBinary ) &#123;</span><br><span class="line">				<span class="keyword">throw</span> <span class="string">"mach-o, but not built for iOSMac"</span>;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> __arm64e__</span></span><br><span class="line">		<span class="keyword">if</span> ( (sMainExecutableMachHeader-&gt;cpusubtype == CPU_SUBTYPE_ARM64_E) &amp;&amp; (mh-&gt;cpusubtype != CPU_SUBTYPE_ARM64_E) )</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"arm64 dylibs cannot be loaded into arm64e processes"</span>;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">		ImageLoader* image = <span class="literal">nullptr</span>;</span><br><span class="line">		&#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_MAP_IMAGE, path, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			<span class="comment">//调用 instantiateFromFile 来实例化 ImageLoader</span></span><br><span class="line">			image = ImageLoaderMachO::instantiateFromFile(path, fd, firstPagesPtr, headerAndLoadCommandsSize, fileOffset, fileLength, stat_buf, gLinkContext);</span><br><span class="line">			timer.setData4((<span class="keyword">uint64_t</span>)image-&gt;machHeader());</span><br><span class="line">		&#125;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">// validate</span></span><br><span class="line">		<span class="comment">// 加入全局链表</span></span><br><span class="line">		<span class="keyword">return</span> checkandAddImage(image, context);</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// try other file formats here...</span></span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// throw error about what was found</span></span><br><span class="line">	<span class="keyword">switch</span> (*(<span class="keyword">uint32_t</span>*)firstPages) &#123;</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM:</span><br><span class="line">		<span class="keyword">case</span> MH_MAGIC_64:</span><br><span class="line">		<span class="keyword">case</span> MH_CIGAM_64:</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"mach-o, but wrong architecture"</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">		throwf(<span class="string">"unknown file type, first eight bytes: 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X 0x%02X"</span>, </span><br><span class="line">			firstPages[<span class="number">0</span>], firstPages[<span class="number">1</span>], firstPages[<span class="number">2</span>], firstPages[<span class="number">3</span>], firstPages[<span class="number">4</span>], firstPages[<span class="number">5</span>], firstPages[<span class="number">6</span>],firstPages[<span class="number">7</span>]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这部分的主要任务就是，从本地文件中加载指定的动态库，并且返回<code>ImageLoader</code>实例对象。</p>
<p>步骤如下：</p>
<ol>
<li>优先读取这个文件的4k，因为一个分页最小是4k,并且解析为 fat_header。</li>
<li>如果这个动态库是个fat文件，就直接找到合适CPU架构的“子文件”</li>
<li>检查文件类型，大小等。</li>
<li>如果 head 和 Load_Commands 的大小大于已读取的4k，那么就继续把剩下的 headerAndLoadCommandsSize 读完，实例化<code>ImageLoader</code>。因为实例化<code>ImageLoader</code>需要整个 Load_Commands 部分。</li>
<li>checkandAddImage。</li>
</ol>
<p>再来看 checkandAddImage：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> ImageLoader* <span class="title">checkandAddImage</span><span class="params">(ImageLoader* image, <span class="keyword">const</span> LoadContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// now sanity check that this loaded image does not have the same install path as any existing image</span></span><br><span class="line">	<span class="comment">// 在sAllImages 中检查一下，是否有同样路径的动态库，如果有，则返回链表中原有的那个镜像</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span>* loadedImageInstallPath = image-&gt;getInstallPath();</span><br><span class="line">	<span class="keyword">if</span> ( image-&gt;isDylib() &amp;&amp; (loadedImageInstallPath != <span class="literal">NULL</span>) &amp;&amp; (loadedImageInstallPath[<span class="number">0</span>] == <span class="string">'/'</span>) ) &#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) &#123;</span><br><span class="line">			ImageLoader* anImage = *it;</span><br><span class="line">			<span class="keyword">const</span> <span class="keyword">char</span>* installPath = anImage-&gt;getInstallPath();</span><br><span class="line">			<span class="keyword">if</span> ( installPath != <span class="literal">NULL</span>) &#123;</span><br><span class="line">				<span class="keyword">if</span> ( <span class="built_in">strcmp</span>(loadedImageInstallPath, installPath) == <span class="number">0</span> ) &#123;</span><br><span class="line">					<span class="comment">//dyld::log("duplicate(%s) =&gt; %p\n", installPath, anImage);</span></span><br><span class="line">					removeImage(image);</span><br><span class="line">					ImageLoader::deleteImage(image);</span><br><span class="line">					<span class="keyword">return</span> anImage;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// some API's restrict what they can load</span></span><br><span class="line">	<span class="keyword">if</span> ( context.mustBeBundle &amp;&amp; !image-&gt;isBundle() )</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"not a bundle"</span>;</span><br><span class="line">	<span class="keyword">if</span> ( context.mustBeDylib &amp;&amp; !image-&gt;isDylib() )</span><br><span class="line">		<span class="keyword">throw</span> <span class="string">"not a dylib"</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// regular main executables cannot be loaded </span></span><br><span class="line">	<span class="keyword">if</span> ( image-&gt;isExecutable() ) &#123;</span><br><span class="line">		<span class="keyword">if</span> ( !context.canBePIE || !image-&gt;isPositionIndependentExecutable() )</span><br><span class="line">			<span class="keyword">throw</span> <span class="string">"can't load a main executable"</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// don't add bundles to global list, they can be loaded but not linked.  When linked it will be added to list</span></span><br><span class="line">	<span class="keyword">if</span> ( ! image-&gt;isBundle() )</span><br><span class="line">		<span class="comment">//加入全局链表中</span></span><br><span class="line">		addImage(image);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>代码很简单，判断这个路径的动态库是不是已经在全局链表中了，已经在的话就直接返回，否则就<code>AddImage</code></p>
<p><a href="#return_loaddylib">返回继续</a></p>
<h3 id="Link-可执行文件"><a href="#Link-可执行文件" class="headerlink" title="Link 可执行文件"></a><span id="jump_link_execution">Link 可执行文件</span></h3><p>标题是链接可执行文件，但是因为这是一个递归操作，所以这一节主要是讲述dyld如何链接所有的动态库。</p>
<p><code>void link(ImageLoader* image, bool forceLazysBound, bool neverUnload, const ImageLoader::RPathChain&amp; loaderRPaths, unsigned cacheIndex)</code></p>
<p>上面是这个函数的方法签名，在_main的执行过程中，首先是可执行文件的 mach-o 镜像 调用，其次紧跟着的是环境变量中插入的动态库会依次调用，这个函数内部最终还是调用到了 <code>ImageLoader.link</code>函数</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::link</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">bool</span> forceLazysBound, <span class="keyword">bool</span> preflightOnly, <span class="keyword">bool</span> neverUnload, <span class="keyword">const</span> RPathChain&amp; loaderRPaths, <span class="keyword">const</span> <span class="keyword">char</span>* imagePath)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//dyld::log("ImageLoader::link(%s) refCount=%d, neverUnload=%d\n", imagePath, fDlopenReferenceCount, fNeverUnload);</span></span><br><span class="line">	</span><br><span class="line">	<span class="comment">// clear error strings</span></span><br><span class="line">	(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> t0 = mach_absolute_time();</span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveLoadLibraries(context, preflightOnly, loaderRPaths, imagePath);</span><br><span class="line">	context.notifyBatch(dyld_image_state_dependents_mapped, preflightOnly);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// we only do the loading step for preflights</span></span><br><span class="line">	<span class="keyword">if</span> ( preflightOnly )</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	context.clearAllDepths();</span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveUpdateDepth(context.imageCount());</span><br><span class="line"></span><br><span class="line">	__block <span class="keyword">uint64_t</span> t2, t3, t4, t5;</span><br><span class="line">	&#123;</span><br><span class="line">		dyld3::ScopedTimer(DBG_DYLD_TIMING_APPLY_FIXUPS, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">		t2 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">this</span>-&gt;recursiveRebase(context);</span><br><span class="line">		context.notifyBatch(dyld_image_state_rebased, <span class="literal">false</span>);</span><br><span class="line"></span><br><span class="line">		t3 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">			<span class="keyword">this</span>-&gt;recursiveBindWithAccounting(context, forceLazysBound, neverUnload);</span><br><span class="line"></span><br><span class="line">		t4 = mach_absolute_time();</span><br><span class="line">		<span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">			<span class="keyword">this</span>-&gt;weakBind(context);</span><br><span class="line">		t5 = mach_absolute_time();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ( !context.linkingMainExecutable )</span><br><span class="line">        context.notifyBatch(dyld_image_state_bound, <span class="literal">false</span>);</span><br><span class="line">	<span class="keyword">uint64_t</span> t6 = mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;DOFInfo&gt; dofs;</span><br><span class="line">	<span class="keyword">this</span>-&gt;recursiveGetDOFSections(context, dofs);</span><br><span class="line">	context.registerDOFs(dofs);</span><br><span class="line">	<span class="keyword">uint64_t</span> t7 = mach_absolute_time();	</span><br><span class="line"></span><br><span class="line">	<span class="comment">// interpose any dynamically loaded images</span></span><br><span class="line">	<span class="keyword">if</span> ( !context.linkingMainExecutable &amp;&amp; (fgInterposingTuples.size() != <span class="number">0</span>) ) &#123;</span><br><span class="line">		<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_APPLY_INTERPOSING, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">		<span class="keyword">this</span>-&gt;recursiveApplyInterposing(context);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// clear error strings</span></span><br><span class="line">	(*context.setErrorStrings)(<span class="number">0</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//计算时间，控制log输出</span></span><br><span class="line">	fgTotalLoadLibrariesTime += t1 - t0;</span><br><span class="line">	fgTotalRebaseTime += t3 - t2;</span><br><span class="line">	fgTotalBindTime += t4 - t3;</span><br><span class="line">	fgTotalWeakBindTime += t5 - t4;</span><br><span class="line">	fgTotalDOF += t7 - t6;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// done with initial dylib loads</span></span><br><span class="line">	fgNextPIEDylibAddress = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链接函数的操作思路很清晰：</p>
<ol>
<li><code>this-&gt;recursiveLoadLibraries</code> 递归加载依赖的所有动态库 (这里仅仅是Load，Load包含open文件以及实例化ImageLoader)，最终的结果和Load通过参数插入的动态库一样。</li>
<li><code>this-&gt;recursiveUpdateDepth</code> 递归刷新依赖库的层级</li>
<li><span id="return_rebase"><code>this-&gt;recursiveRebase</code></span><br> 每一个动态库的递归rebase无非就是再次依次调用，当前动态库所依赖的其他动态库的recursiveRebase。真正rebase是在<code>rebase(const LinkContext&amp; context, uintptr_t slide)</code>。<a href="#jump_rebase">Rebase</a></li>
<li><code>this-&gt;recursiveBindWithAccounting</code><br> 这里就是经典的non-lazy bind和lazy bind了。和Rebase的代码结构类似，真正的rebind是在<code>doBind(const LinkContext&amp; context, bool forceLazysBound)</code>。</li>
<li><code>this-&gt;weakBind</code> 弱符号绑定</li>
<li><code>this-&gt;recursiveGetDOFSections</code> 注册DOF节</li>
<li><code>this-&gt;recursiveApplyInterposing</code></li>
</ol>
<p>其中每一个步骤都会有一个时间戳，用来根据可控的环境变量来输出log。</p>
<h3 id="Rebase"><a href="#Rebase" class="headerlink" title="Rebase"></a><span id="jump_rebase">Rebase</span></h3><p>首先解释一下 Rebase ：</p>
<p>都知道，Rebase是调整动态库内部的符号，因为ASLR，内核加载的时候会在随机的地址中映射动态库。一开始我的想法是，mach-o的动态库在编译期已经做了PIC（地址无关代码），为什么还会有”rebase”这个过程？</p>
<p>事实上PIC确实存在，但是rebase也是必须的。</p>
<p>举个例子：在动态库/可执行文件 初始化 的过程中有一个步骤是构造器初始化(这个步骤本文也有具体说明)，而实现这个这个步骤的，实际上是在mach-o的数据段中有一个名为<code>__mod_init_func</code>的段，而这个段存储的指针数组就是构造器初始化函数的地址。说到这就比较明显了，在dyld 寻找构造器初始化地址指针的时候，已经不再是以数据段中的vmaddr为基准了，而是需要加上一个偏移 – slide。</p>
<p>下面就按照上面例子，看看代码中是如何实现这一步骤的，compressed mach-o(现代版本的好像几乎都是这个压缩的mach-o格式了) 在这一节上做了压缩，因此实现都在<code>ImageLoaderMachOCompressed</code>中。</p>
<p>先分析一下 rebase 这一节在mach-o内的数据结构</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/ffdc0da28d16d220f66e8d638a7d5198.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>每一个 rebase 信息都由若干个 操作码 – 操作数 来描述，每一个记录都包含两个元素（opcode 和 immediate），可以理解为一个操作码，一个是操作数，这两个都可以通过掩码来获取。</p>
<p>以第一个为例：<br>REBASE_OPCODE_TYPE_IMM == 11:标识操作数是一个Type，而Type是个指针<br>REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB == 22:当前rebase的数据在第2个segment，并且偏移是用uleb表示<br>uleb128 == 24:上面提到的uleb值<br>REBASE_OPCODE_DO_REBASE_IMM_TIMES == 2:当前rebase操作执行2次。</p>
<p>总结：在第2个段开始往后偏移24个字节的指针地址，连续执行两次rebase。</p>
<p>再看看：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/69f3c8a3511f6c75d8798c62db21d597.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>0是起始段，那么第2段就是数据段。我们再找，段的文件偏移 0x3000 + 偏移 24 =0x3018 。</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/8479e0316c7f0447ff14dd0a1b98ed69.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>没错，就是这两个构造器，并且当前节就是<code>__mod_init_func</code>~。</p>
<p>下面是rebase的源码，当然在本例中有些 操作码 和 操作数 并没有用到。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoaderMachOCompressed::rebase</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">uintptr_t</span> slide)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRSetCrashLogMessage2(<span class="keyword">this</span>-&gt;getPath());</span><br><span class="line">	<span class="comment">// fLinkEditBase 是__LINKEDIT段在 内存实际偏移与预期偏移 的 差值 （== slide？）</span></span><br><span class="line">	<span class="comment">// start 的值是 rebase信息在内存中的实际起始地址</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> start = fLinkEditBase + fDyldInfo-&gt;rebase_off;</span><br><span class="line">	<span class="comment">// end 的值是 rebase信息在内存中的实际结束地址</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* <span class="keyword">const</span> end = &amp;start[fDyldInfo-&gt;rebase_size];</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">uint8_t</span>* p = start;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		<span class="keyword">uint8_t</span> type = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">int</span> segmentIndex = <span class="number">0</span>;</span><br><span class="line">		<span class="keyword">uintptr_t</span> address = segActualLoadAddress(<span class="number">0</span>);</span><br><span class="line">		<span class="keyword">uintptr_t</span> segmentStartAddress = segActualLoadAddress(<span class="number">0</span>);<span class="comment">//第N个段地址的实际开始地址</span></span><br><span class="line">		<span class="keyword">uintptr_t</span> segmentEndAddress = segActualEndAddress(<span class="number">0</span>);<span class="comment">//第N个段的实际结束地址</span></span><br><span class="line">		<span class="keyword">uintptr_t</span> count;</span><br><span class="line">		<span class="keyword">uintptr_t</span> skip;</span><br><span class="line">		<span class="keyword">bool</span> done = <span class="literal">false</span>;</span><br><span class="line">		<span class="keyword">while</span> ( !done &amp;&amp; (p &lt; end) ) &#123;</span><br><span class="line">			<span class="keyword">uint8_t</span> immediate = *p &amp; REBASE_IMMEDIATE_MASK;</span><br><span class="line">			<span class="keyword">uint8_t</span> opcode = *p &amp; REBASE_OPCODE_MASK;</span><br><span class="line">			++p;</span><br><span class="line">			<span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DONE:</span><br><span class="line">					done = <span class="literal">true</span>;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_SET_TYPE_IMM:</span><br><span class="line">					type = immediate;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB:</span><br><span class="line">					segmentIndex = immediate;</span><br><span class="line">					<span class="keyword">if</span> ( segmentIndex &gt;= fSegmentsCount )</span><br><span class="line">						dyld::throwf(<span class="string">"REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is too large (0..%d)"</span>,</span><br><span class="line">								segmentIndex, fSegmentsCount<span class="number">-1</span>);</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">if</span> TEXT_RELOC_SUPPORT</span></span><br><span class="line">					<span class="keyword">if</span> ( !segWriteable(segmentIndex) &amp;&amp; !segHasRebaseFixUps(segmentIndex) &amp;&amp; !segHasBindFixUps(segmentIndex) )</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">					<span class="keyword">if</span> ( !segWriteable(segmentIndex) )</span><br><span class="line">			<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">						dyld::throwf(<span class="string">"REBASE_OPCODE_SET_SEGMENT_AND_OFFSET_ULEB has segment %d which is not a writable segment (%s)"</span>,</span><br><span class="line">								segmentIndex, segName(segmentIndex));</span><br><span class="line">					<span class="comment">//读取当前段的实际开始和结束地址</span></span><br><span class="line">					segmentStartAddress = segActualLoadAddress(segmentIndex);</span><br><span class="line">					segmentEndAddress = segActualEndAddress(segmentIndex);</span><br><span class="line">					</span><br><span class="line">					address = segmentStartAddress + read_uleb128(p, end);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_ADD_ADDR_ULEB:</span><br><span class="line">					address += read_uleb128(p, end);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_ADD_ADDR_IMM_SCALED:</span><br><span class="line">					address += immediate*<span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_IMM_TIMES:</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">0</span>; i &lt; immediate; ++i) &#123;<span class="comment">//循环N次</span></span><br><span class="line">						<span class="keyword">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class="line">							throwBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">						rebaseAt(context, address, slide, type);</span><br><span class="line">						address += <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					fgTotalRebaseFixups += immediate;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES:</span><br><span class="line">					count = read_uleb128(p, end);</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class="line">							throwBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">						rebaseAt(context, address, slide, type);</span><br><span class="line">						address += <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					fgTotalRebaseFixups += count;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ADD_ADDR_ULEB:</span><br><span class="line">					<span class="keyword">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class="line">						throwBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">					rebaseAt(context, address, slide, type);</span><br><span class="line">					address += read_uleb128(p, end) + <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">					++fgTotalRebaseFixups;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">case</span> REBASE_OPCODE_DO_REBASE_ULEB_TIMES_SKIPPING_ULEB:</span><br><span class="line">					count = read_uleb128(p, end);</span><br><span class="line">					skip = read_uleb128(p, end);</span><br><span class="line">					<span class="keyword">for</span> (<span class="keyword">uint32_t</span> i=<span class="number">0</span>; i &lt; count; ++i) &#123;</span><br><span class="line">						<span class="keyword">if</span> ( (address &lt; segmentStartAddress) || (address &gt;= segmentEndAddress) )</span><br><span class="line">							throwBadRebaseAddress(address, segmentEndAddress, segmentIndex, start, end, p);</span><br><span class="line">						rebaseAt(context, address, slide, type);</span><br><span class="line">						address += skip + <span class="keyword">sizeof</span>(<span class="keyword">uintptr_t</span>);</span><br><span class="line">					&#125;</span><br><span class="line">					fgTotalRebaseFixups += count;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				<span class="keyword">default</span>:</span><br><span class="line">					dyld::throwf(<span class="string">"bad rebase opcode %d"</span>, *(p<span class="number">-1</span>));</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="keyword">const</span> <span class="keyword">char</span>* newMsg = dyld::mkstringf(<span class="string">"%s in %s"</span>, msg, <span class="keyword">this</span>-&gt;getPath());</span><br><span class="line">		<span class="built_in">free</span>((<span class="keyword">void</span>*)msg);</span><br><span class="line">		<span class="keyword">throw</span> newMsg;</span><br><span class="line">	&#125;</span><br><span class="line">	CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="initializeMainExecutable"><a href="#initializeMainExecutable" class="headerlink" title="initializeMainExecutable"></a><span id="jump_init_main_execution">initializeMainExecutable</span></h2><p>其实到这里动态库的加载/rebase/bind…都已经完成了，而这一步要做的就是初始化构造器函数了，这里也就是runtime初始化的过程。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">initializeMainExecutable</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record that we've reached this step</span></span><br><span class="line">	gLinkContext.startedInitializingMainExecutable = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// run initialzers for any inserted dylibs</span></span><br><span class="line">	ImageLoader::InitializerTimingList initializerTimes[allImagesCount()];</span><br><span class="line">	initializerTimes[<span class="number">0</span>].count = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">size_t</span> rootCount = sImageRoots.size();</span><br><span class="line">	<span class="keyword">if</span> ( rootCount &gt; <span class="number">1</span> ) &#123;</span><br><span class="line">		<span class="keyword">for</span>(<span class="keyword">size_t</span> i=<span class="number">1</span>; i &lt; rootCount; ++i) &#123;</span><br><span class="line">			sImageRoots[i]-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// run initializers for main executable and everything it brings up </span></span><br><span class="line">	sMainExecutable-&gt;runInitializers(gLinkContext, initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	</span><br><span class="line">	<span class="comment">// register cxa_atexit() handler to run static terminators in all loaded images when this process exits</span></span><br><span class="line">	<span class="keyword">if</span> ( gLibSystemHelpers != <span class="literal">NULL</span> ) </span><br><span class="line">		(*gLibSystemHelpers-&gt;cxa_atexit)(&amp;runAllStaticTerminators, <span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">	<span class="comment">// dump info if requested</span></span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS )</span><br><span class="line">		ImageLoader::printStatistics((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">	<span class="keyword">if</span> ( sEnv.DYLD_PRINT_STATISTICS_DETAILS )</span><br><span class="line">		ImageLoaderMachO::printStatisticsDetails((<span class="keyword">unsigned</span> <span class="keyword">int</span>)allImagesCount(), initializerTimes[<span class="number">0</span>]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优先初始化插入的动态库，再初始化可执行文件。</p>
<p>sMainExecutable-&gt;runInitializers 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::runInitializers</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, InitializerTimingList&amp; timingInfo)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">	<span class="keyword">mach_port_t</span> thisThread = mach_thread_self();</span><br><span class="line">	ImageLoader::UninitedUpwards up;</span><br><span class="line">	up.count = <span class="number">1</span>;</span><br><span class="line">	up.images[<span class="number">0</span>] = <span class="keyword">this</span>;</span><br><span class="line">	processInitializers(context, thisThread, timingInfo, up);</span><br><span class="line">	context.notifyBatch(dyld_image_state_initialized, <span class="literal">false</span>);</span><br><span class="line">	mach_port_deallocate(mach_task_self(), thisThread);</span><br><span class="line">	<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">	fgTotalInitTime += (t2 - t1);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>processInitializers 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::processInitializers</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> thisThread,</span></span></span><br><span class="line"><span class="function"><span class="params">									 InitializerTimingList&amp; timingInfo, ImageLoader::UninitedUpwards&amp; images)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">uint32_t</span> maxImageCount = context.imageCount()+<span class="number">2</span>;</span><br><span class="line">	ImageLoader::UninitedUpwards upsBuffer[maxImageCount];</span><br><span class="line">	ImageLoader::UninitedUpwards&amp; ups = upsBuffer[<span class="number">0</span>];</span><br><span class="line">	ups.count = <span class="number">0</span>;</span><br><span class="line">	<span class="comment">// Calling recursive init on all images in images list, building a new list of</span></span><br><span class="line">	<span class="comment">// uninitialized upward dependencies.</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="keyword">uintptr_t</span> i=<span class="number">0</span>; i &lt; images.count; ++i) &#123;</span><br><span class="line">		images.images[i]-&gt;recursiveInitialization(context, thisThread, images.images[i]-&gt;getPath(), timingInfo, ups);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">// If any upward dependencies remain, init them.</span></span><br><span class="line">	<span class="keyword">if</span> ( ups.count &gt; <span class="number">0</span> )</span><br><span class="line">		processInitializers(context, thisThread, timingInfo, ups);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>recursiveInitialization 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ImageLoader::recursiveInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context, <span class="keyword">mach_port_t</span> this_thread, <span class="keyword">const</span> <span class="keyword">char</span>* pathToInitialize,</span></span></span><br><span class="line"><span class="function"><span class="params">										  InitializerTimingList&amp; timingInfo, UninitedUpwards&amp; uninitUps)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="function">recursive_lock <span class="title">lock_info</span><span class="params">(this_thread)</span></span>;</span><br><span class="line">	recursiveSpinLock(lock_info);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ( fState &lt; dyld_image_state_dependents_initialized<span class="number">-1</span> ) &#123;</span><br><span class="line">		<span class="keyword">uint8_t</span> oldState = fState;</span><br><span class="line">		<span class="comment">// break cycles</span></span><br><span class="line">		fState = dyld_image_state_dependents_initialized<span class="number">-1</span>;</span><br><span class="line">		<span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">// initialize lower level libraries first</span></span><br><span class="line">			<span class="keyword">for</span>(<span class="keyword">unsigned</span> <span class="keyword">int</span> i=<span class="number">0</span>; i &lt; libraryCount(); ++i) &#123;</span><br><span class="line">				ImageLoader* dependentImage = libImage(i);</span><br><span class="line">				<span class="keyword">if</span> ( dependentImage != <span class="literal">NULL</span> ) &#123;</span><br><span class="line">					<span class="comment">// don't try to initialize stuff "above" me yet</span></span><br><span class="line">					<span class="keyword">if</span> ( libIsUpward(i) ) &#123;</span><br><span class="line">						uninitUps.images[uninitUps.count] = dependentImage;</span><br><span class="line">						uninitUps.count++;</span><br><span class="line">					&#125;</span><br><span class="line">					<span class="keyword">else</span> <span class="keyword">if</span> ( dependentImage-&gt;fDepth &gt;= fDepth ) &#123;</span><br><span class="line">						dependentImage-&gt;recursiveInitialization(context, this_thread, libPath(i), timingInfo, uninitUps);</span><br><span class="line">					&#125;</span><br><span class="line">                &#125;</span><br><span class="line">			&#125;</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// record termination order</span></span><br><span class="line">			<span class="keyword">if</span> ( <span class="keyword">this</span>-&gt;needsTermination() )</span><br><span class="line">				context.terminationRecorder(<span class="keyword">this</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// let objc know we are about to initialize this image</span></span><br><span class="line">			<span class="keyword">uint64_t</span> t1 = mach_absolute_time();</span><br><span class="line">			fState = dyld_image_state_dependents_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_dependents_initialized, <span class="keyword">this</span>, &amp;timingInfo);</span><br><span class="line">			</span><br><span class="line">			<span class="comment">// initialize this image</span></span><br><span class="line">			<span class="keyword">bool</span> hasInitializers = <span class="keyword">this</span>-&gt;doInitialization(context);</span><br><span class="line"></span><br><span class="line">			<span class="comment">// let anyone know we finished initializing this image</span></span><br><span class="line">			fState = dyld_image_state_initialized;</span><br><span class="line">			oldState = fState;</span><br><span class="line">			context.notifySingle(dyld_image_state_initialized, <span class="keyword">this</span>, <span class="literal">NULL</span>);</span><br><span class="line">			</span><br><span class="line">			<span class="keyword">if</span> ( hasInitializers ) &#123;</span><br><span class="line">				<span class="keyword">uint64_t</span> t2 = mach_absolute_time();</span><br><span class="line">				timingInfo.addTime(<span class="keyword">this</span>-&gt;getShortName(), t2-t1);</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">			<span class="comment">// this image is not initialized</span></span><br><span class="line">			fState = oldState;</span><br><span class="line">			recursiveSpinUnLock();</span><br><span class="line">			<span class="keyword">throw</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">	recursiveSpinUnLock();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>doInitialization 函数：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ImageLoaderMachO::doInitialization</span><span class="params">(<span class="keyword">const</span> LinkContext&amp; context)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	CRSetCrashLogMessage2(<span class="keyword">this</span>-&gt;getPath());</span><br><span class="line"></span><br><span class="line">	<span class="comment">// mach-o has -init and static initializers</span></span><br><span class="line">	doImageInit(context);</span><br><span class="line">	doModInitFunctions(context);</span><br><span class="line">	</span><br><span class="line">	CRSetCrashLogMessage2(<span class="literal">NULL</span>);</span><br><span class="line">	</span><br><span class="line">	<span class="keyword">return</span> (fHasDashInit || fHasInitializers);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最终调到 doModInitFunctions 函数，实现逻辑和上文提到的dyld的自身的初始化一样，遍历调用_mod_init_func中的方法指针。</p>
<p>runtime就是在这里被初始化的，调试一下就可以看到:</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/6880c3f245ce10b72f214d8851b959e5.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>调用栈和上面描述的一样，最终由 libSystem.B.dylib -&gt; libdispatch.dylib -&gt; libobjc.A.dylib 这个调用顺序初始化了runtime。<br>而runtime 的这个函数，在dyld反向注册了三个回调函数。<br><code>_dyld_objc_notify_register(&amp;map_images, load_images, unmap_image);</code></p>
<p>而这个注册函数会把每个已经load完的镜像同步地回调给runtime：</p>
<figure class="image-bubble">
                <div class="img-lightbox">
                    <div class="overlay"></div>
                    <img src="https://blog-caio.oss-cn-hongkong.aliyuncs.com/blog/2020/03/d26ee1e5057ed5fc0c63d13baac4b77b.png" alt="" title="">
                </div>
                <div class="image-caption"></div>
            </figure>

<p>从代码中我们也可以确认：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">registerObjCNotifiers</span><span class="params">(_dyld_objc_notify_mapped mapped, _dyld_objc_notify_init init, _dyld_objc_notify_unmapped unmapped)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">// record functions to call</span></span><br><span class="line">	sNotifyObjCMapped	= mapped;</span><br><span class="line">	sNotifyObjCInit		= init;</span><br><span class="line">	sNotifyObjCUnmapped = unmapped;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// call 'mapped' function with all images mapped so far</span></span><br><span class="line">	<span class="keyword">try</span> &#123;</span><br><span class="line">		notifyBatchPartial(dyld_image_state_bound, <span class="literal">true</span>, <span class="literal">NULL</span>, <span class="literal">false</span>, <span class="literal">true</span>);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">catch</span> (<span class="keyword">const</span> <span class="keyword">char</span>* msg) &#123;</span><br><span class="line">		<span class="comment">// ignore request to abort during registration</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">// &lt;rdar://problem/32209809&gt; call 'init' function on all images already init'ed (below libSystem)</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="built_in">std</span>::<span class="built_in">vector</span>&lt;ImageLoader*&gt;::iterator it=sAllImages.begin(); it != sAllImages.end(); it++) &#123;</span><br><span class="line">		ImageLoader* image = *it;</span><br><span class="line">		<span class="keyword">if</span> ( (image-&gt;getState() == dyld_image_state_initialized) &amp;&amp; image-&gt;notifyObjC() ) &#123;</span><br><span class="line">			<span class="function">dyld3::ScopedTimer <span class="title">timer</span><span class="params">(DBG_DYLD_TIMING_OBJC_INIT, (<span class="keyword">uint64_t</span>)image-&gt;machHeader(), <span class="number">0</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">			(*sNotifyObjCInit)(image-&gt;getRealPath(), image-&gt;machHeader());</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>遍历 sAllImages ，回调给 <code>_dyld_objc_notify_init init</code>函数。runtime就可以根据mach-o的 class 有关的 section 开始初始化了。</p>
<h2 id="参考文献"><a href="#参考文献" class="headerlink" title="参考文献"></a><span id="jump_end">参考文献</span></h2><ol>
<li><a href="https://www.dllhook.com/post/249.html" target="_blank" rel="noopener">内嵌汇编的一些黑科技：访问自身Mach-O、调用函数等</a></li>
<li><a href="https://paper.seebug.org/202/" target="_blank" rel="noopener">Mach-O脱壳技巧</a></li>
<li><a href="https://www.dllhook.com/post/238.html" target="_blank" rel="noopener">dyld详解</a></li>
<li><a href="http://blog.sunnyxx.com/2014/08/30/objc-pre-main/" target="_blank" rel="noopener">iOS 程序 main 函数之前发生了什么</a></li>
<li><a href="https://feicong.github.io/2017/01/14/dylib/index.html" target="_blank" rel="noopener">dylib动态库加载过程分析</a></li>
</ol>

        </div>

        <blockquote class="post-copyright">
    
    <div class="content">
        

        
        留言区，暂未开放......
        
    </div>
    
    <footer>
        <a href="https://caio.ink">
            <img src="/img/avatar.jpg" alt="Caio">
            Caio
        </a>
    </footer>
</blockquote>

        


        <div class="post-footer">
            
	<ul class="article-tag-list" itemprop="keywords"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/%E5%8A%A8%E6%80%81%E9%93%BE%E6%8E%A5/" rel="tag">动态链接</a></li></ul>


            
<div class="page-share-wrap">
    

<div class="page-share" id="pageShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://caio.ink/2020/03/13/11.dyld/&title=《详解 dyld 加载过程》 — Caio's Blog&pic=https://caio.ink/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://caio.ink/2020/03/13/11.dyld/&title=《详解 dyld 加载过程》 — Caio's Blog&source=Life goes on and on" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://caio.ink/2020/03/13/11.dyld/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《详解 dyld 加载过程》 — Caio's Blog&url=https://caio.ink/2020/03/13/11.dyld/&via=https://caio.ink" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://caio.ink/2020/03/13/11.dyld/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>



    <a href="javascript:;" id="shareFab" class="page-share-fab waves-effect waves-circle">
        <i class="icon icon-share-alt icon-lg"></i>
    </a>
</div>



        </div>
    </div>

    
<nav class="post-nav flex-row flex-justify-between">
  
    <div class="waves-block waves-effect prev">
      <a href="/2020/03/15/12.compiler-autorelease-opt/" id="post-prev" class="post-nav-link">
        <div class="tips"><i class="icon icon-angle-left icon-lg icon-pr"></i> Prev</div>
        <h4 class="title">当编译优化遇上AutoRelease优化</h4>
      </a>
    </div>
  

  
    <div class="waves-block waves-effect next">
      <a href="/2020/03/04/10.runloop-binary-search/" id="post-next" class="post-nav-link">
        <div class="tips">Next <i class="icon icon-angle-right icon-lg icon-pl"></i></div>
        <h4 class="title">RunLoop中&#34;奇怪&#34;的二分查找</h4>
      </a>
    </div>
  
</nav>



    




















</article>



</div>

        <footer class="footer">
    <div class="top">
        

        <p>
            
            <span>博客内容遵循 <a rel="license noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" target="_blank">知识共享 署名 - 非商业性 - 相同方式共享 4.0 国际协议</a></span>
        </p>
    </div>
    <div class="bottom">
        <p><span>Caio &copy; 2019 - 2020</span>
            <span>
                
                Power by <a href="http://hexo.io/" target="_blank">Hexo</a> Theme <a href="https://github.com/yscoder/hexo-theme-indigo" target="_blank">indigo</a>
            </span>
        </p>
    </div>
</footer>

    </main>
    <div class="mask" id="mask"></div>
<a href="javascript:;" id="gotop" class="waves-effect waves-circle waves-light"><span class="icon icon-lg icon-chevron-up"></span></a>



<div class="global-share" id="globalShare">
    <ul class="reset share-icons">
      <li>
        <a class="weibo share-sns" target="_blank" href="http://service.weibo.com/share/share.php?url=https://caio.ink/2020/03/13/11.dyld/&title=《详解 dyld 加载过程》 — Caio's Blog&pic=https://caio.ink/img/avatar.jpg" data-title="微博">
          <i class="icon icon-weibo"></i>
        </a>
      </li>
      <li>
        <a class="weixin share-sns wxFab" href="javascript:;" data-title="微信">
          <i class="icon icon-weixin"></i>
        </a>
      </li>
      <li>
        <a class="qq share-sns" target="_blank" href="http://connect.qq.com/widget/shareqq/index.html?url=https://caio.ink/2020/03/13/11.dyld/&title=《详解 dyld 加载过程》 — Caio's Blog&source=Life goes on and on" data-title=" QQ">
          <i class="icon icon-qq"></i>
        </a>
      </li>
      <li>
        <a class="facebook share-sns" target="_blank" href="https://www.facebook.com/sharer/sharer.php?u=https://caio.ink/2020/03/13/11.dyld/" data-title=" Facebook">
          <i class="icon icon-facebook"></i>
        </a>
      </li>
      <li>
        <a class="twitter share-sns" target="_blank" href="https://twitter.com/intent/tweet?text=《详解 dyld 加载过程》 — Caio's Blog&url=https://caio.ink/2020/03/13/11.dyld/&via=https://caio.ink" data-title=" Twitter">
          <i class="icon icon-twitter"></i>
        </a>
      </li>
      <li>
        <a class="google share-sns" target="_blank" href="https://plus.google.com/share?url=https://caio.ink/2020/03/13/11.dyld/" data-title=" Google+">
          <i class="icon icon-google-plus"></i>
        </a>
      </li>
    </ul>
 </div>


<div class="page-modal wx-share" id="wxShare">
    <a class="close" href="javascript:;"><i class="icon icon-close"></i></a>
    <p>扫一扫，分享到微信</p>
    <img src="//api.qrserver.com/v1/create-qr-code/?data=https://caio.ink/2020/03/13/11.dyld/" alt="微信分享二维码">
</div>




    <script src="//cdn.bootcss.com/node-waves/0.7.4/waves.min.js"></script>
<script>
var BLOG = { ROOT: '/', SHARE: true, REWARD: false };


</script>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/main.min.js"></script>


<div class="search-panel" id="search-panel">
    <ul class="search-result" id="search-result"></ul>
</div>
<template id="search-tpl">
<li class="item">
    <a href="{path}" class="waves-block waves-effect">
        <div class="title ellipsis" title="{title}">{title}</div>
        <div class="flex-row flex-middle">
            <div class="tags ellipsis">
                {tags}
            </div>
            <time class="flex-col time">{date}</time>
        </div>
    </a>
</li>
</template>

<script src="//unpkg.com/hexo-theme-material-indigo@latest/js/search.min.js" async></script>








<script>
(function() {
    var OriginTitile = document.title, titleTime;
    document.addEventListener('visibilitychange', function() {
        if (document.hidden) {
            document.title = '你快回来...';
            clearTimeout(titleTime);
        } else {
            document.title = '回来啦~';
            titleTime = setTimeout(function() {
                document.title = OriginTitile;
            },2000);
        }
    });
})();
</script>



</body>
</html>
